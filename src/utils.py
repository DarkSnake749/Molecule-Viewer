from math import sin, cos, pi
from panda3d.core import (
    GeomVertexFormat, GeomVertexData, Geom, GeomTriangles, GeomNode,
    GeomVertexWriter, Vec3, Vec4, NodePath, TransparencyAttrib
)

from rdkit import Chem
from rdkit.Chem import AllChem



# * 3d functions

def make_sphere(render, radius=1.0, color=(1, 0, 0, 1), slices=32, stacks=16):
    # Generated by ChatGPT 5.0

    """
    Procedurally create a colored sphere.

    Args:
        render (NodePath): The parent node (usually base.render).
        radius (float): Radius of the sphere.
        color (tuple): RGBA color, each value between 0–1.
        slices (int): Number of horizontal divisions.
        stacks (int): Number of vertical divisions.

    Returns:
        NodePath: The sphere node.
    """

    format = GeomVertexFormat.get_v3n3c4()
    vdata = GeomVertexData('sphere', format, Geom.UH_static)

    vertex = GeomVertexWriter(vdata, 'vertex')
    normal = GeomVertexWriter(vdata, 'normal')
    color_writer = GeomVertexWriter(vdata, 'color')

    # Generate vertices
    for i in range(stacks + 1):
        phi = pi * i / stacks
        for j in range(slices + 1):
            theta = 2 * pi * j / slices
            x = radius * sin(phi) * cos(theta)
            y = radius * sin(phi) * sin(theta)
            z = radius * cos(phi)
            vertex.add_data3(x, y, z)
            normal.add_data3(Vec3(x, y, z).normalized())
            color_writer.add_data4f(*color)

    # Generate triangles
    tris = GeomTriangles(Geom.UH_static)
    for i in range(stacks):
        for j in range(slices):
            i1 = i * (slices + 1) + j
            i2 = i1 + slices + 1
            tris.add_vertices(i1, i2, i1 + 1)
            tris.add_vertices(i1 + 1, i2, i2 + 1)

    geom = Geom(vdata)
    geom.add_primitive(tris)
    node = GeomNode('sphere')
    node.add_geom(geom)

    sphere_np = render.attach_new_node(node)
    sphere_np.set_two_sided(True)

    # Enable transparency if alpha < 1.0
    if color[3] < 1.0:
        sphere_np.set_transparency(TransparencyAttrib.M_alpha)
        sphere_np.set_depth_write(False)  # Helps avoid z-sorting artifacts

    return sphere_np

def make_cylinder(render, radius=1.0, height=2.0, color=(1, 0, 0, 1), slices=32):
    # Generated by ChatGPT 5.0

    """
    Procedurally create a colored cylinder and attach it to the scene graph.

    Args:
        render (NodePath): The parent node (usually base.render).
        radius (float): Radius of the cylinder base.
        height (float): Height of the cylinder.
        color (tuple): RGBA color, each value between 0–1.
        slices (int): Number of radial divisions (smoothness).

    Returns:
        NodePath: The cylinder NodePath.
    """

    format = GeomVertexFormat.get_v3n3c4()
    vdata = GeomVertexData('cylinder', format, Geom.UH_static)

    vertex = GeomVertexWriter(vdata, 'vertex')
    normal = GeomVertexWriter(vdata, 'normal')
    color_writer = GeomVertexWriter(vdata, 'color')

    # Top and bottom z-coordinates
    half_h = height / 2.0

    # --- Generate side vertices ---
    for i in range(slices + 1):
        theta = 2 * pi * i / slices
        x = radius * cos(theta)
        y = radius * sin(theta)
        nx = cos(theta)
        ny = sin(theta)

        # Bottom vertex
        vertex.add_data3(x, y, -half_h)
        normal.add_data3(nx, ny, 0)
        color_writer.add_data4f(*color)

        # Top vertex
        vertex.add_data3(x, y, half_h)
        normal.add_data3(nx, ny, 0)
        color_writer.add_data4f(*color)

    tris = GeomTriangles(Geom.UH_static)

    # --- Create side triangles ---
    for i in range(slices):
        i1 = i * 2
        i2 = i1 + 1
        i3 = (i1 + 2) % ((slices + 1) * 2)
        i4 = (i1 + 3) % ((slices + 1) * 2)
        tris.add_vertices(i1, i3, i2)
        tris.add_vertices(i2, i3, i4)

    # --- Generate top and bottom caps ---
    start_index = (slices + 1) * 2
    for z, nz in [(half_h, 1), (-half_h, -1)]:
        center_index = vdata.get_num_rows()
        vertex.add_data3(0, 0, z)
        normal.add_data3(0, 0, nz)
        color_writer.add_data4f(*color)

        base_index = 0 if nz < 0 else 1
        for i in range(slices):
            i1 = i * 2 + base_index
            i2 = ((i + 1) % slices) * 2 + base_index
            if nz > 0:
                tris.add_vertices(center_index, i1, i2)
            else:
                tris.add_vertices(center_index, i2, i1)

    # --- Finalize geometry ---
    geom = Geom(vdata)
    geom.add_primitive(tris)
    node = GeomNode('cylinder')
    node.add_geom(geom)

    cylinder_np = render.attach_new_node(node)
    cylinder_np.set_two_sided(True)

    # Enable transparency if alpha < 1.0
    if color[3] < 1.0:
        cylinder_np.set_transparency(TransparencyAttrib.M_alpha)
        cylinder_np.set_depth_write(False)

    return cylinder_np

def update_shape_color(shape, color):
    """
    Update the color of a certain shape. Can handle transparency.
    """

    shape.set_color(color)

    # Enable transparency if alpha < 1.0
    if color[3] < 1.0:
        shape.set_transparency(TransparencyAttrib.M_alpha)
        shape.set_depth_write(False) # Helps avoid z-sorting artifacts



# * Chem function

def smiles_to_3d_data(smiles: str):
    # Generated by ChatGPT 5.0

    """
    Convert a SMILES string into a simple, structured 3D molecular representation.

    Returns
    -------
    dict with:
        - 'atoms': list of {'element', 'x', 'y', 'z'}
        - 'bonds': list of {'start', 'end', 'order'}
    """
    mol = Chem.MolFromSmiles(smiles)
    if mol is None:
        raise ValueError(f"Invalid SMILES: {smiles}")

    mol = Chem.AddHs(mol)
    params = AllChem.ETKDGv3()
    params.randomSeed = 0xf00d
    if AllChem.EmbedMolecule(mol, params) != 0:
        raise RuntimeError("3D embedding failed")
    AllChem.UFFOptimizeMolecule(mol)

    conf = mol.GetConformer()

    # Collect atoms
    atoms = []
    for atom in mol.GetAtoms():
        pos = conf.GetAtomPosition(atom.GetIdx())
        atoms.append({
            "element": atom.GetSymbol(),
            "x": pos.x,
            "y": pos.y,
            "z": pos.z
        })

    # Collect bonds
    bonds = []
    for bond in mol.GetBonds():
        bonds.append({
            "start": bond.GetBeginAtomIdx(),
            "end": bond.GetEndAtomIdx(),
            "order": bond.GetBondTypeAsDouble()
        })

    return {
        "atoms": atoms,
        "bonds": bonds
    }

